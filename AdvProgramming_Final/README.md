<<<<<<< HEAD
Polars: Exploring a modern DataFrame Library for PythonAuthor: Maria Jose ZunigaCourse: Advanced ProgrammingLibrary: PolarsTopic: Why Would a Data Scientist Use This?OverviewThis project explores Polars, a modern and high-performance DataFrame library written in Rust.The goal of this notebook is to demonstrate how Polars handles data analysis tasks efficiently, what makes it unique compared to traditional Python tools, and why a data scientist might adopt it for large-scale or performance-sensitive work.Rather than competing with Pandas, this project shows how Polars redefines the same tasks, data loading, filtering, grouping, and aggregation, using a faster, more expressive, and parallelized approachLibraries UsedPolars Ð Fast, multi-threaded DataFrame library written in RustPandas Ð Classic Python library for data manipulationMatplotlib Ð Used for quick visualizations of data distributionsTime Ð Built-in Python module for performance measurementRequirementsPython 3.8+To install dependencies:pip install polars pandas matplotlib What This Notebook Demonstrates1. Dataset Loading Ð Compare how fast Pandas and Polars can load the same dataset2. Filtering & Grouping Ð Extract the most recent year and compute the average overweight rate of female toddlers per U.S. state3. Performance Comparison Ð Measure and compare read and computation times4. Lazy API Demo Ð Show how PolarsÕ lazy execution improves efficiency by optimizing queries before running themDataset OverviewSource: Data.gov Ð Nutrition, Physical Activity, and Obesity: Women, Infant, and Child (WIC)Size: ~12,800 rows ? 31 columnsFocus: Percentage of WIC toddlers classified as overweight (2008Ð2020).Key Columns:* YearEnd ? Year of observation* StratificationCategory1 / Stratification1 ? Category & value (e.g., Sex = Female)* Data_Value ? % of overweight toddlers* LocationAbbr ? U.S. state abbreviationPolars vs Pandas Ð Key TakeawaysAspectPandasPolarsExecution modelSingle-threadedMulti-threadedMemory backendNumpyApache ArrowPerformanceSlower on large data? Faster, optimizedSyntaxImperativeExpression-based (pl.col())Advanced featuresLimitedLazy API, parallelizationInsights* Polars was consistently 2Ð4? faster than Pandas in reading and aggregation.* Both produced identical numerical results, confirming accuracy.* The Lazy API allows optimization before execution Ñ ideal for large ETL pipelines.* Syntax in Polars feels more declarative and chainable, reducing intermediate variables.ReflectionThis project reinforced how library design choices affect performance and usability.Pandas remains ideal for quick exploration or small datasets, but Polars stands out for production-scale work or machine learning preprocessing.Project ContentsFileDescriptionMidterm_MJZ_Polars.ipynbMain Jupyter Notebook with all steps and codeREADME.mdThis project summary and documentationdata_wic.csvDataset used for analysis (if included)Resources* Polars Documentation ? https://pola-rs.github.io/polars-book/* Apache Arrow Project ? https://arrow.apache.org/* PEP-8 Style Guide ? https://peps.python.org/pep-0008/
=======
# OIM_7502_classwork
>>>>>>> 63df3ac3cec9c93598457216a17ba74e79b8ab25
